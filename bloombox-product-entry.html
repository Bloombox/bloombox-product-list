
<!--
`<bloombox-product-entry>` provides UI for an individual generic product item in a
`<bloombox-product-list>`.

@group Bloombox Elements
@element bloombox-product-entry
@demo demo/index.html
@homepage bloombox.github.io
-->

<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../iron-label/iron-label.html">
<link rel="import" href="../iron-icons/iron-icons.html">

<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">

<link rel="import" href="../bloombox-icons/bloombox-icons.html">
<link rel="import" href="../bloombox-styles/bloombox-styles.html">


<dom-module id="bloombox-product-entry">
  <template strip-whitespace>
    <style is="custom-style" include="bloombox-styles">
      :host {
        height: 50px;
        background: white;
      }

      :host div[hidden] {
        display: none;
      }

      :host paper-item {
        height: 50px;
        pointer-events: none;
      }

      :host,
      :host paper-item,
      :host paper-item paper-item-body {
        max-height: 50px;
        break-inside: avoid;
        page-break-inside: avoid;
      }

      :host iron-label {
        font-size: 85%;
        display: block;
      }

      /** -- left side -- **/
      :host paper-item iron-icon {
        margin-right: 10px;
        width: 24px;
        height: 24px;
      }

      :host paper-item .item-name {
        margin-right: 30px;
        position: relative;
        top: 2px;
        display: inline-block;
      }

      :host paper-item.all-pricing {
        padding: 0 0;
      }

      :host paper-item.all-pricing .item-name {
        display: inline-block;
        height: 50px;
        line-height: 50px;
        top: 0;
      }

      :host paper-item .entry-data {
        cursor: default;
      }

      :host paper-item .left-aligned-entry-data {
        flex: 1 0 210px;
      }

      :host paper-item .right-aligned-entry-data {
        flex: 1 1 70%;
        display: flex;
      }

      :host paper-item .left-aligned-entry-data div[secondary] {
        display: flex;
        font-size: 75%;
      }

      /** -- right side -- **/
      :host paper-item .product-entry-content {
        line-height: 13px;
      }

      :host paper-item.all-pricing .product-testing-content {
        flex: 2 0 80px;
        height: 50px;
        line-height: 16px;
        margin-top: 7px;
      }

      :host paper-item.all-pricing .price-value-unavailable {
        opacity: 0.4;
        color: #888;
      }

      :host paper-item .product-testing-content {
        flex: 2 0 20%;
      }

      :host paper-item.branded-product .product-testing-content {
        margin-top: 10px;
      }

      :host paper-item .product-testing-content iron-label .rating-label-name {
        font-weight: bold;
        font-size: 80%;
        margin-right: 8px;
      }

      :host paper-item .product-pricing-content {
        flex: 1 1 60%;
        display: flex;
        justify-content: flex-end;
        text-align: center;
        align-items: center;
      }

      :host paper-item.product-entry-out-of-stock iron-icon {
        opacity: 0.3;
      }

      :host paper-item.product-entry-out-of-stock paper-item-body {
        opacity: 0.3;
      }

      :host paper-item.product-entry-out-of-stock paper-item-body .item-name {
        font-weight: normal !important;
      }

      :host paper-item-body {
        width: 100%;
        display: flex;
      }

      :host paper-item-body .right-aligned-entry-data .pricing-box {
        display: inline-block;
        white-space: nowrap;
      }

      :host paper-item-body .right-aligned-entry-data .pricing-box .tiered-pricing-value {
        font-size: 14pt;
        max-width: 100px;
        min-width: 80px;
        display: inline-block;
        height: 50px;
        line-height: 50px;
      }
    </style>

    <paper-item class$="[[_stockClasses]]">
      <iron-icon icon="[[icon]]" hidden$="[[multiselect]]"></iron-icon>

      <paper-item-body two-line$="[[_hasBrand]]">
        <div class="left-aligned-entry-data">
          <paper-checkbox hidden$="[[!multiselect]]" checked="{{selected}}"></paper-checkbox>
          <b class="item-name entry-data">[[_renderProductName(product, partner)]]</b>

          <div secondary hidden$="[[!_hasBrand]]">
            <span class="product-entry-brand">[[product.brand]]</span>
          </div>
        </div>

        <div class="right-aligned-entry-data" hidden$="[[multiselect]]">
          <div class="product-entry-content product-testing-content">
            <iron-label class="rating-label thc-label"><span class="rating-label-name">THC</span>[[_renderRatingLabel(product.tests.thc)]]</iron-label>
            <iron-label class="rating-label cbd-label"><span class="rating-label-name">CBD</span>[[_renderRatingLabel(product.tests.cbd)]]</iron-label>
          </div><!-- end div.product-testing-content -->
          <div class="product-entry-content product-pricing-content">
            <div class="pricing-box">
              <template is="dom-if" if="[[!allPrices]]" strip-whitespace>
                <span class="pricing-value">$[[_renderBasePriceValue(product)]][[_renderBasePriceUnit(product)]]</span>
              </template>
              <template is="dom-if" if="[[allPrices]]" strip-whitespace>
                <template is="dom-repeat" items="[[_itemPriceTiers]]" as="price">
                  <span class$="[[_renderPriceClasses(price)]]">$[[_renderTieredPriceValue(price)]]</span>
                </template>
              </template>
            </div><!-- end div.pricing-box -->
          </div>
        </div><!-- end div.right-aligned-entry-data -->
      </paper-item-body>
    </paper-item>
  </template>
  
  <script>
    var productPriceTierLabels = {
          "quartergram": ".25g",
          "halfgram": ".5g",
          "gram": "g",
          "eighth": "3.5g",
          "quarter": "7g",
          "half": "14g",
          "ounce": "28g",
          "unit": "Each"
        },

        productPriceTierOrder = [
          "quartergram",
          "halfgram",
          "gram",
          "eighth",
          "quarter",
          "half",
          "ounce"
        ];

    Polymer.BloomboxProductEntry = Polymer({
      is: 'bloombox-product-entry',

      properties: {
        /**
         * Computed property that provides a set of classes
         * to style this product entry.
         */
        _stockClasses: {
          type: String,
          notify: true,
          computed: '_computeStockClasses(product, _hasBrand, allPrices)'
        },

        /**
         * Computed property to indicate to the UI that we
         * have a valid product brand.
         */
        _hasBrand: {
          type: Boolean,
          notify: true,
          computed: '_computeHasBrand(product)'
        },

        /**
         * Computed property that provides an array of each
         * price tier for a given product, should the product
         * be displaying in `allPrices` mode.
         */
        _itemPriceTiers: {
          type: Array,
          notify: true,
          computed: '_computeItemPriceTiers(product)'
        },

        /**
         * Currently-active partner that we are rendering this
         * data for. Examples include `abatin` and `mm`.
         */
        partner: {
          type: String,
          notify: true
        },

        /**
         * Currently-active dashboard environment that we are
         * rendering this data under. Examples include `v1` and
         * `sandbox`.
         */
        environment: {
          type: String,
          notify: false
        },

        /**
         * Key for the current product object.
         */
        key: {
          type: String,
          notify: true,
          reflectToAttribute: true
        },

        /**
         * Data value for the current product object.
         */
        product: {
          type: Object,
          notify: true
        },

        /**
         * Holds the section for which we are currently
         * showing data.
         */
        section: {
          type: String,
          notify: true,
          reflectToAttribute: true
        },

        /**
         * Whether the current item is selected or not.
         */
        selected: {
          type: Boolean,
          notify: true,
          value: false,
          reflectToAttribute: true
        },

        /**
         * Whether we should show all prices, or just the most
         * sensible/popular one.
         */
        allPrices: {
          type: Boolean,
          notify: true,
          value: false,
          reflectToAttribute: true
        },

        /**
         * Activate or deactivate multiselection UI.
         */
        multiselect: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true,
          value: false,
          observer: '_multiselectDidChange'
        },

        /**
         * Computes the icon to show at the beginning of
         * the row.
         */
        icon: {
          type: String,
          notify: true,
          computed: '_computeIcon(section, product)'
        }
      },

      /**
       * Computes classes that should be applied to this
       * product entry.
       */
      _computeStockClasses: function(product, hasBrand, allPrices) {
        var classes = ["product-item-entry-content"];
        if (product.flags !== undefined &&
            product.flags.visible === false) {
          classes.push("product-entry-out-of-stock");
        }
        if (hasBrand === true)
          classes.push("branded-product");
        if (allPrices === true)
          classes.push("all-pricing");
        return classes.join(" ");
      },

      /**
       * Computes the presence of a valid brand on the
       * current product.
       */
      _computeHasBrand: function(product) {
        return product.brand != null
               && product.brand !== undefined
               && typeof product.brand === "string"
               && product.brand.length > 0;
      },

      /**
       * Computes the icon to show at the beginning of the
       * row for this product.
       */
      _computeIcon: function(section, product) {
        if (section === "flowers") {
          if (product.species === "Sativa")
            return "bloombox:sativa-circle";
          if (product.species === "Indica")
            return "bloombox:indica-circle";
        }
        return "bloombox:hybrid-circle";
      },

      /**
       * Compute the price tiers that should be shown for an
       * object that is being rendered in `allPrices` mode.
       */
      _computeItemPriceTiers: function(product) {
        var i, p, t, tiers = [];
        if (product.pricelist !== undefined) {
          // flower pricing
          for (i in productPriceTierOrder) {
            t = productPriceTierOrder[i];
            if (product.pricelist[t] !== undefined) {
              p = product.pricelist[t];
              tiers.push({
                tier: t,
                label: productPriceTierLabels[t],
                available: p.available,
                value: p.price
              });
            }
          }
        } else if (product.pricing !== undefined) {
          // unit pricing
          if (product.pricing.unit !== undefined) {
            tiers.push({
              tier: "unit",
              label: productPriceTierLabels["unit"],
              available: product.pricing.unit.available,
              value: product.pricing.unit.value
            });
          } else {
            console.warn("Unable to determine price tiers for product.", product);
          }
        } else {
          console.warn("Unable to determine price tiers for product.", product);
        }
        return tiers;
      },

      /**
       * Observes changes to `multiselect` and reacts when it is
       * turned off, namely deselecting any previously-selected
       * items.
       */
      _multiselectDidChange: function(newValue, oldValue) {
        if (newValue === false && oldValue === true ||
            newValue === true && oldValue === false) {
          // we are shutting off or turning on multiselect
          this.selected = false;
        }
      },

      /**
       * Render a product name as it should be shown, according to
       * the currently-active partner and product flags.
       */
      _renderProductName: function(product, partner) {
        var name = product.name,
            flags = product.flags,
            grow = product.grow;
        if (partner === "abatin" && (grow !== undefined && grow !== null && typeof grow === "string")) {
          if (grow === "Greenhouse") {
            name = "GH " + name;
          } else if (grow === "Outdoor") {
            name = "FS " + name;
          }
        }
        if (partner === "abatin" && (flags !== undefined && flags !== null && flags.premium === true))
          return "MPMH " + name;
        return name;
      },

      /**
       * Renders a rating test value into a readable piece
       * of text for the UI.
       */
      _renderRatingLabel: function(value) {
        var mode = this.product.tests !== undefined ? this.product.tests.mode : null;
        if (typeof mode === "string")
          return [value, mode].join("");
        if (value === 0 || value === undefined || value == null)
          return "None";
        if (value > 100 || Number(value) === value && value % 1 === 0)
          return [value, "mg"].join("");
        return [value, "%"].join("");
      },

      /**
       * Renders the base price value for this product. Base
       * price is defined differently based on object type.
       *
       * - For weighted pricing, the lowest weight available is
       *   used. Except for concentrates, this is usually `1g`.
       * - For unit pricing, the price of each unit is used.
       */
      _renderBasePriceValue: function(value) {
        if (value.pricelist !== undefined) {
          return value.pricelist.gram.price;
        } else if (value.pricing !== undefined) {
          if (value.pricing.unit !== undefined) {
            return value.pricing.unit.value;
          } else {
            if (value.pricing.gram !== undefined &&
                value.pricing.gram.value > 0) {
              return value.pricing.gram.value;
            } else if (value.pricing.quartergram !== undefined &&
                       value.pricing.quartergram > 0) {
              return value.pricing.quartergram.value;
            } else if (value.pricing.halfgram !== undefined) {
              return value.pricing.halfgram.value;
            } else {
              console.warn("Unable to render pricing for value.", value);
            }
          }
        }
        return "error";
      },

      /**
       * Renders the postfix for the price in the UI, indicating
       * the unit by which pricing is decided. Base price and unit
       * is defined differently based on object type.
       *
       * - For weighted pricing, the lowest weight available is
       *   used. Except for concentrates, this is usually `1g`.
       * - For unit pricing, the price of each unit is used.
       */
      _renderBasePriceUnit: function(value) {
        if (value.pricelist !== undefined) {
          return "/g";
        } else if (value.pricing !== undefined) {
          if (value.pricing.unit !== undefined) {
            return "";
          } else {
            if (value.pricing.gram !== undefined &&
                value.pricing.gram.value > 0) {
              return "/g";
            } else if (value.pricing.quartergram !== undefined &&
                       value.pricing.quartergram > 0) {
              return "/.25g";
            } else if (value.pricing.halfgram !== undefined) {
              return "/.5g";
            } else {
              console.warn("Unable to render pricing base for value.", value);
            }
          }
        }
        return "";
      },

      /**
       * Renders a price value and unit for an arbitrary price tier,
       * when rendering `allPrices` for a given product.
       */
      _renderTieredPriceValue: function(price) {
        return [price.value].join("/");
      },

      /**
       * Generate a list of classes to add to a particular price box
       * for a particular item, based on the price data and whether
       * the product is `available` at that weight/price.
       */
      _renderPriceClasses: function(price) {
        var cls = ["pricing-value", "tiered-pricing-value"];
        if (price.available !== true) {
          cls.push("price-value-unavailable");
        }
        return cls.join(" ");
      }
    });
  </script>
</dom-module>
